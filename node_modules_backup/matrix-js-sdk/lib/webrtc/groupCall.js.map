{"version":3,"file":"groupCall.js","names":["GroupCallIntent","GroupCallType","GroupCallTerminationReason","GroupCallEvent","GroupCallErrorCode","GroupCallError","Error","constructor","code","msg","err","GroupCallUnknownDeviceError","userId","UnknownDevice","OtherUserSpeakingError","GroupCallState","DEVICE_TIMEOUT","getCallUserId","call","getOpponentMember","invitee","GroupCall","TypedEventEmitter","client","room","type","isPtt","intent","groupCallId","dataChannelsEnabled","dataChannelOptions","Map","LocalCallFeedUninitialized","newCall","roomId","state","CallState","Ringing","logger","warn","log","reject","opponent","undefined","deviceMap","calls","get","prevCall","getOpponentDeviceId","callId","disposeCall","CallErrorCode","Replaced","initCall","answerWithCallFeeds","getLocalFeeds","map","feed","clone","set","emit","CallsChanged","needsRetry","member","participantMap","participants","callMap","retriesMap","retryCallCounts","deviceId","participant","retries","getOpponentSessionId","sessionId","wantsOutgoingCall","placeOutgoingCalls","opponentMemberId","opponentDeviceId","currentUserMediaFeed","getUserMediaFeed","remoteUsermediaFeed","remoteFeedChanged","addUserMediaFeed","replaceUserMediaFeed","removeUserMediaFeed","currentScreenshareFeed","getScreenshareFeed","remoteScreensharingFeed","remoteScreenshareFeedChanged","addScreenshareFeed","replaceScreenshareFeed","removeScreenshareFeed","_oldState","audioMuted","localCallFeed","isAudioMuted","localUsermediaStream","isMicrophoneMuted","setMicrophoneMuted","videoMuted","isVideoMuted","isLocalVideoMuted","setLocalVideoMuted","Connected","delete","size","hangupReason","getMember","topAvg","nextActiveSpeaker","callFeed","userMediaFeeds","isLocal","length","total","speakingVolumeSamples","reduce","acc","volume","Math","max","SPEAKING_THRESHOLD","avg","activeSpeaker","ActiveSpeakerChanged","updateParticipants","Entered","newState","oldState","Ended","updateMemberState","catch","e","error","reEmitter","ReEmitter","genCallID","creationTs","currentState","getStateEvents","EventType","GroupCallPrefix","getTs","on","RoomStateEvent","Update","onRoomState","ParticipantsChanged","onParticipantsChanged","GroupCallStateChanged","onStateChanged","LocalScreenshareStateChanged","onLocalFeedsChanged","create","Date","now","groupCallEventHandler","groupCalls","GroupCallEventHandlerEvent","Outgoing","sendStateEvent","_state","value","prevValue","_participants","participantStateEqual","x","y","screensharing","deviceMapsEqual","mapsEqual","_creationTs","enteredViaAnotherSession","_enteredViaAnotherSession","forEachCall","f","values","feeds","push","localScreenshareFeed","hasLocalParticipant","getUserId","has","getDeviceId","initLocalCallFeed","InitializingLocalCallFeed","stream","disposed","onState","getMediaHandler","getUserMediaStream","Video","off","CallFeed","purpose","SDPStreamMetadataPurpose","Usermedia","initWithAudioMuted","getAudioTracks","initWithVideoMuted","getVideoTracks","setTracksEnabled","LocalCallFeedInitialized","updateLocalUsermediaStream","oldStream","setNewStream","micShouldBeMuted","vidShouldBeMuted","id","stopUserMediaStream","enter","CallEventHandlerEvent","Incoming","onIncomingCall","callEventHandler","retryCallLoopInterval","setInterval","onRetryCallLoop","retryCallInterval","onActiveSpeakerLoop","activeSpeakerLoopInterval","activeSpeakerInterval","dispose","stopScreensharingStream","localDesktopCapturerSourceId","stopAllStreams","transmitTimer","clearTimeout","clearInterval","UserHangup","clear","removeListener","leave","terminate","emitStateEvent","existingStateEvent","getContent","CallEnded","muted","hasAudioDevice","sendUpdatesBefore","setTimeout","pttMaxTransmitTime","localUsermediaFeed","setAudioVideoMuted","sendUpdates","updates","sendMetadataUpdate","Promise","all","info","LocalMuteStateChanged","hasVideoDevice","setScreensharingEnabled","enabled","opts","isScreensharing","getScreensharingStream","track","getTracks","onTrackEnded","removeEventListener","addEventListener","desktopCapturerSourceId","Screenshare","pushLocalFeed","throwOnFail","NoUserMedia","localScreensharingFeed","removeLocalFeed","localUserId","localDeviceId","callsChanged","debug","NewSession","createNewMatrixCall","opponentSessionId","placeCallWithCallFeeds","then","createDataChannel","CallError","PlaceCallFailed","SignallingFailed","getMemberStateEvents","GroupCallMemberPrefix","onCallFeedsChanged","onCallStateChanged","onCallHangup","onCallReplaced","callHandlers","CallEvent","FeedsChanged","State","Hangup","reEmit","Object","hangup","usermediaFeed","screenshareFeed","find","measureVolumeActivity","UserMediaFeedsChanged","existingFeed","replacementFeed","feedIndex","findIndex","splice","screenshareFeeds","ScreenshareFeedsChanged","participantsExpirationTimer","entered","nextExpiration","Infinity","getStateKey","content","Array","isArray","devices","validDevices","filter","d","device_id","session_id","expires_ts","membership","some","localMember","getSessionId","updateDevices","fn","keepAlive","event","otherCalls","c","newDevices","newCalls","newContent","addDeviceToMemberState","resendMemberStateTimer","cleanMemberState","myDevices","getDevices","device","last_seen_ts"],"sources":["../../src/webrtc/groupCall.ts"],"sourcesContent":["import { TypedEventEmitter } from \"../models/typed-event-emitter\";\nimport { CallFeed, SPEAKING_THRESHOLD } from \"./callFeed\";\nimport { MatrixClient, IMyDevice } from \"../client\";\nimport {\n    CallErrorCode,\n    CallEvent,\n    CallEventHandlerMap,\n    CallState,\n    genCallID,\n    MatrixCall,\n    setTracksEnabled,\n    createNewMatrixCall,\n    CallError,\n} from \"./call\";\nimport { RoomMember } from \"../models/room-member\";\nimport { Room } from \"../models/room\";\nimport { RoomStateEvent } from \"../models/room-state\";\nimport { logger } from \"../logger\";\nimport { ReEmitter } from \"../ReEmitter\";\nimport { SDPStreamMetadataPurpose } from \"./callEventTypes\";\nimport { MatrixEvent } from \"../models/event\";\nimport { EventType } from \"../@types/event\";\nimport { CallEventHandlerEvent } from \"./callEventHandler\";\nimport { GroupCallEventHandlerEvent } from \"./groupCallEventHandler\";\nimport { IScreensharingOpts } from \"./mediaHandler\";\nimport { mapsEqual } from \"../utils\";\n\nexport enum GroupCallIntent {\n    Ring = \"m.ring\",\n    Prompt = \"m.prompt\",\n    Room = \"m.room\",\n}\n\nexport enum GroupCallType {\n    Video = \"m.video\",\n    Voice = \"m.voice\",\n}\n\nexport enum GroupCallTerminationReason {\n    CallEnded = \"call_ended\",\n}\n\nexport enum GroupCallEvent {\n    GroupCallStateChanged = \"group_call_state_changed\",\n    ActiveSpeakerChanged = \"active_speaker_changed\",\n    CallsChanged = \"calls_changed\",\n    UserMediaFeedsChanged = \"user_media_feeds_changed\",\n    ScreenshareFeedsChanged = \"screenshare_feeds_changed\",\n    LocalScreenshareStateChanged = \"local_screenshare_state_changed\",\n    LocalMuteStateChanged = \"local_mute_state_changed\",\n    ParticipantsChanged = \"participants_changed\",\n    Error = \"error\",\n}\n\nexport type GroupCallEventHandlerMap = {\n    [GroupCallEvent.GroupCallStateChanged]: (newState: GroupCallState, oldState: GroupCallState) => void;\n    [GroupCallEvent.ActiveSpeakerChanged]: (activeSpeaker: CallFeed | undefined) => void;\n    [GroupCallEvent.CallsChanged]: (calls: Map<RoomMember, Map<string, MatrixCall>>) => void;\n    [GroupCallEvent.UserMediaFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.ScreenshareFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.LocalScreenshareStateChanged]: (\n        isScreensharing: boolean, feed?: CallFeed, sourceId?: string,\n    ) => void;\n    [GroupCallEvent.LocalMuteStateChanged]: (audioMuted: boolean, videoMuted: boolean) => void;\n    [GroupCallEvent.ParticipantsChanged]: (participants: Map<RoomMember, Map<string, ParticipantState>>) => void;\n    [GroupCallEvent.Error]: (error: GroupCallError) => void;\n};\n\nexport enum GroupCallErrorCode {\n    NoUserMedia = \"no_user_media\",\n    UnknownDevice = \"unknown_device\",\n    PlaceCallFailed = \"place_call_failed\"\n}\n\nexport class GroupCallError extends Error {\n    public code: string;\n\n    public constructor(code: GroupCallErrorCode, msg: string, err?: Error) {\n        // Still don't think there's any way to have proper nested errors\n        if (err) {\n            super(msg + \": \" + err);\n        } else {\n            super(msg);\n        }\n\n        this.code = code;\n    }\n}\n\nexport class GroupCallUnknownDeviceError extends GroupCallError {\n    public constructor(public userId: string) {\n        super(GroupCallErrorCode.UnknownDevice, \"No device found for \" + userId);\n    }\n}\n\nexport class OtherUserSpeakingError extends Error {\n    public constructor() {\n        super(\"Cannot unmute: another user is speaking\");\n    }\n}\n\nexport interface IGroupCallDataChannelOptions {\n    ordered: boolean;\n    maxPacketLifeTime: number;\n    maxRetransmits: number;\n    protocol: string;\n}\n\nexport interface IGroupCallRoomMemberFeed {\n    purpose: SDPStreamMetadataPurpose;\n    // TODO: Sources for adaptive bitrate\n}\n\nexport interface IGroupCallRoomMemberDevice {\n    \"device_id\": string;\n    \"session_id\": string;\n    \"expires_ts\": number;\n    \"feeds\": IGroupCallRoomMemberFeed[];\n}\n\nexport interface IGroupCallRoomMemberCallState {\n    \"m.call_id\": string;\n    \"m.foci\"?: string[];\n    \"m.devices\": IGroupCallRoomMemberDevice[];\n}\n\nexport interface IGroupCallRoomMemberState {\n    \"m.calls\": IGroupCallRoomMemberCallState[];\n}\n\nexport enum GroupCallState {\n    LocalCallFeedUninitialized = \"local_call_feed_uninitialized\",\n    InitializingLocalCallFeed = \"initializing_local_call_feed\",\n    LocalCallFeedInitialized = \"local_call_feed_initialized\",\n    Entered = \"entered\",\n    Ended = \"ended\",\n}\n\nexport interface ParticipantState {\n    sessionId: string;\n    screensharing: boolean;\n}\n\ninterface ICallHandlers {\n    onCallFeedsChanged: (feeds: CallFeed[]) => void;\n    onCallStateChanged: (state: CallState, oldState: CallState | undefined) => void;\n    onCallHangup: (call: MatrixCall) => void;\n    onCallReplaced: (newCall: MatrixCall) => void;\n}\n\nconst DEVICE_TIMEOUT = 1000 * 60 * 60; // 1 hour\n\nfunction getCallUserId(call: MatrixCall): string | null {\n    return call.getOpponentMember()?.userId || call.invitee || null;\n}\n\nexport class GroupCall extends TypedEventEmitter<\n    GroupCallEvent | CallEvent,\n    GroupCallEventHandlerMap & CallEventHandlerMap\n> {\n    // Config\n    public activeSpeakerInterval = 1000;\n    public retryCallInterval = 5000;\n    public participantTimeout = 1000 * 15;\n    public pttMaxTransmitTime = 1000 * 20;\n\n    public activeSpeaker?: CallFeed;\n    public localCallFeed?: CallFeed;\n    public localScreenshareFeed?: CallFeed;\n    public localDesktopCapturerSourceId?: string;\n    public readonly calls = new Map<RoomMember, Map<string, MatrixCall>>();\n    public readonly userMediaFeeds: CallFeed[] = [];\n    public readonly screenshareFeeds: CallFeed[] = [];\n    public groupCallId: string;\n\n    private callHandlers = new Map<string, Map<string, ICallHandlers>>(); // User ID -> device ID -> handlers\n    private activeSpeakerLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallCounts: Map<RoomMember, Map<string, number>> = new Map();\n    private reEmitter: ReEmitter;\n    private transmitTimer: ReturnType<typeof setTimeout> | null = null;\n    private participantsExpirationTimer: ReturnType<typeof setTimeout> | null = null;\n    private resendMemberStateTimer: ReturnType<typeof setInterval> | null = null;\n    private initWithAudioMuted = false;\n    private initWithVideoMuted = false;\n\n    public constructor(\n        private client: MatrixClient,\n        public room: Room,\n        public type: GroupCallType,\n        public isPtt: boolean,\n        public intent: GroupCallIntent,\n        groupCallId?: string,\n        private dataChannelsEnabled?: boolean,\n        private dataChannelOptions?: IGroupCallDataChannelOptions,\n    ) {\n        super();\n        this.reEmitter = new ReEmitter(this);\n        this.groupCallId = groupCallId ?? genCallID();\n        this.creationTs = room.currentState.getStateEvents(\n            EventType.GroupCallPrefix, this.groupCallId,\n        )?.getTs() ?? null;\n        this.updateParticipants();\n\n        room.on(RoomStateEvent.Update, this.onRoomState);\n        this.on(GroupCallEvent.ParticipantsChanged, this.onParticipantsChanged);\n        this.on(GroupCallEvent.GroupCallStateChanged, this.onStateChanged);\n        this.on(GroupCallEvent.LocalScreenshareStateChanged, this.onLocalFeedsChanged);\n    }\n\n    public async create(): Promise<GroupCall> {\n        this.creationTs = Date.now();\n        this.client.groupCallEventHandler!.groupCalls.set(this.room.roomId, this);\n        this.client.emit(GroupCallEventHandlerEvent.Outgoing, this);\n\n        await this.client.sendStateEvent(\n            this.room.roomId,\n            EventType.GroupCallPrefix,\n            {\n                \"m.intent\": this.intent,\n                \"m.type\": this.type,\n                \"io.element.ptt\": this.isPtt,\n                // TODO: Specify datachannels\n                \"dataChannelsEnabled\": this.dataChannelsEnabled,\n                \"dataChannelOptions\": this.dataChannelOptions,\n            },\n            this.groupCallId,\n        );\n\n        return this;\n    }\n\n    private _state = GroupCallState.LocalCallFeedUninitialized;\n\n    /**\n     * The group call's state.\n     */\n    public get state(): GroupCallState {\n        return this._state;\n    }\n\n    private set state(value: GroupCallState) {\n        const prevValue = this._state;\n        if (value !== prevValue) {\n            this._state = value;\n            this.emit(GroupCallEvent.GroupCallStateChanged, value, prevValue);\n        }\n    }\n\n    private _participants = new Map<RoomMember, Map<string, ParticipantState>>();\n\n    /**\n     * The current participants in the call, as a map from members to device IDs\n     * to participant info.\n     */\n    public get participants(): Map<RoomMember, Map<string, ParticipantState>> {\n        return this._participants;\n    }\n\n    private set participants(value: Map<RoomMember, Map<string, ParticipantState>>) {\n        const prevValue = this._participants;\n        const participantStateEqual = (x: ParticipantState, y: ParticipantState): boolean =>\n            x.sessionId === y.sessionId && x.screensharing === y.screensharing;\n        const deviceMapsEqual = (x: Map<string, ParticipantState>, y: Map<string, ParticipantState>): boolean =>\n            mapsEqual(x, y, participantStateEqual);\n\n        // Only update if the map actually changed\n        if (!mapsEqual(value, prevValue, deviceMapsEqual)) {\n            this._participants = value;\n            this.emit(GroupCallEvent.ParticipantsChanged, value);\n        }\n    }\n\n    private _creationTs: number | null = null;\n\n    /**\n     * The timestamp at which the call was created, or null if it has not yet\n     * been created.\n     */\n    public get creationTs(): number | null {\n        return this._creationTs;\n    }\n\n    private set creationTs(value: number | null) {\n        this._creationTs = value;\n    }\n\n    private _enteredViaAnotherSession = false;\n\n    /**\n     * Whether the local device has entered this call via another session, such\n     * as a widget.\n     */\n    public get enteredViaAnotherSession(): boolean {\n        return this._enteredViaAnotherSession;\n    }\n\n    public set enteredViaAnotherSession(value: boolean) {\n        this._enteredViaAnotherSession = value;\n        this.updateParticipants();\n    }\n\n    /**\n     * Executes the given callback on all calls in this group call.\n     * @param f The callback.\n     */\n    public forEachCall(f: (call: MatrixCall) => void): void {\n        for (const deviceMap of this.calls.values()) {\n            for (const call of deviceMap.values()) f(call);\n        }\n    }\n\n    public getLocalFeeds(): CallFeed[] {\n        const feeds: CallFeed[] = [];\n\n        if (this.localCallFeed) feeds.push(this.localCallFeed);\n        if (this.localScreenshareFeed) feeds.push(this.localScreenshareFeed);\n\n        return feeds;\n    }\n\n    public hasLocalParticipant(): boolean {\n        return this.participants.get(\n            this.room.getMember(this.client.getUserId()!)!,\n        )?.has(this.client.getDeviceId()!) ?? false;\n    }\n\n    public async initLocalCallFeed(): Promise<CallFeed> {\n        logger.log(`groupCall ${this.groupCallId} initLocalCallFeed`);\n\n        if (this.state !== GroupCallState.LocalCallFeedUninitialized) {\n            throw new Error(`Cannot initialize local call feed in the \"${this.state}\" state.`);\n        }\n\n        this.state = GroupCallState.InitializingLocalCallFeed;\n\n        let stream: MediaStream;\n\n        let disposed = false;\n        const onState = (state: GroupCallState): void => {\n            if (state === GroupCallState.LocalCallFeedUninitialized) {\n                disposed = true;\n            }\n        };\n        this.on(GroupCallEvent.GroupCallStateChanged, onState);\n\n        try {\n            stream = await this.client.getMediaHandler().getUserMediaStream(true, this.type === GroupCallType.Video);\n        } catch (error) {\n            this.state = GroupCallState.LocalCallFeedUninitialized;\n            throw error;\n        } finally {\n            this.off(GroupCallEvent.GroupCallStateChanged, onState);\n        }\n\n        // The call could've been disposed while we were waiting\n        if (disposed) throw new Error(\"Group call disposed\");\n\n        const callFeed = new CallFeed({\n            client: this.client,\n            roomId: this.room.roomId,\n            userId: this.client.getUserId()!,\n            deviceId: this.client.getDeviceId()!,\n            stream,\n            purpose: SDPStreamMetadataPurpose.Usermedia,\n            audioMuted: this.initWithAudioMuted || stream.getAudioTracks().length === 0 || this.isPtt,\n            videoMuted: this.initWithVideoMuted || stream.getVideoTracks().length === 0,\n        });\n\n        setTracksEnabled(stream.getAudioTracks(), !callFeed.isAudioMuted());\n        setTracksEnabled(stream.getVideoTracks(), !callFeed.isVideoMuted());\n\n        this.localCallFeed = callFeed;\n        this.addUserMediaFeed(callFeed);\n\n        this.state = GroupCallState.LocalCallFeedInitialized;\n\n        return callFeed;\n    }\n\n    public async updateLocalUsermediaStream(stream: MediaStream): Promise<void> {\n        if (this.localCallFeed) {\n            const oldStream = this.localCallFeed.stream;\n            this.localCallFeed.setNewStream(stream);\n            const micShouldBeMuted = this.localCallFeed.isAudioMuted();\n            const vidShouldBeMuted = this.localCallFeed.isVideoMuted();\n            logger.log(`groupCall ${this.groupCallId} updateLocalUsermediaStream oldStream ${\n                oldStream.id} newStream ${stream.id} micShouldBeMuted ${\n                micShouldBeMuted} vidShouldBeMuted ${vidShouldBeMuted}`);\n            setTracksEnabled(stream.getAudioTracks(), !micShouldBeMuted);\n            setTracksEnabled(stream.getVideoTracks(), !vidShouldBeMuted);\n            this.client.getMediaHandler().stopUserMediaStream(oldStream);\n        }\n    }\n\n    public async enter(): Promise<void> {\n        if (this.state === GroupCallState.LocalCallFeedUninitialized) {\n            await this.initLocalCallFeed();\n        } else if (this.state !== GroupCallState.LocalCallFeedInitialized) {\n            throw new Error(`Cannot enter call in the \"${this.state}\" state`);\n        }\n\n        logger.log(`Entered group call ${this.groupCallId}`);\n        this.state = GroupCallState.Entered;\n\n        this.client.on(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            this.onIncomingCall(call);\n        }\n\n        this.retryCallLoopInterval = setInterval(this.onRetryCallLoop, this.retryCallInterval);\n\n        this.activeSpeaker = undefined;\n        this.onActiveSpeakerLoop();\n        this.activeSpeakerLoopInterval = setInterval(\n            this.onActiveSpeakerLoop,\n            this.activeSpeakerInterval,\n        );\n    }\n\n    private dispose(): void {\n        if (this.localCallFeed) {\n            this.removeUserMediaFeed(this.localCallFeed);\n            this.localCallFeed = undefined;\n        }\n\n        if (this.localScreenshareFeed) {\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n        }\n\n        this.client.getMediaHandler().stopAllStreams();\n\n        if (this.transmitTimer !== null) {\n            clearTimeout(this.transmitTimer);\n            this.transmitTimer = null;\n        }\n\n        if (this.retryCallLoopInterval !== undefined) {\n            clearInterval(this.retryCallLoopInterval);\n            this.retryCallLoopInterval = undefined;\n        }\n\n        if (this.state !== GroupCallState.Entered) {\n            return;\n        }\n\n        this.forEachCall(call => this.disposeCall(call, CallErrorCode.UserHangup));\n        this.calls.clear();\n\n        this.activeSpeaker = undefined;\n        clearInterval(this.activeSpeakerLoopInterval);\n\n        this.retryCallCounts.clear();\n        clearInterval(this.retryCallLoopInterval);\n\n        this.client.removeListener(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n    }\n\n    public leave(): void {\n        this.dispose();\n        this.state = GroupCallState.LocalCallFeedUninitialized;\n    }\n\n    public async terminate(emitStateEvent = true): Promise<void> {\n        this.dispose();\n\n        this.room.off(RoomStateEvent.Update, this.onRoomState);\n        this.client.groupCallEventHandler!.groupCalls.delete(this.room.roomId);\n        this.client.emit(GroupCallEventHandlerEvent.Ended, this);\n        this.state = GroupCallState.Ended;\n\n        if (emitStateEvent) {\n            const existingStateEvent = this.room.currentState.getStateEvents(\n                EventType.GroupCallPrefix, this.groupCallId,\n            )!;\n\n            await this.client.sendStateEvent(\n                this.room.roomId,\n                EventType.GroupCallPrefix,\n                {\n                    ...existingStateEvent.getContent(),\n                    \"m.terminated\": GroupCallTerminationReason.CallEnded,\n                },\n                this.groupCallId,\n            );\n        }\n    }\n\n    /*\n     * Local Usermedia\n     */\n\n    public isLocalVideoMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isVideoMuted();\n        }\n\n        return true;\n    }\n\n    public isMicrophoneMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isAudioMuted();\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's microphone.\n     * @param {boolean} muted Whether to mute the microphone\n     * @returns {Promise<boolean>} Whether muting/unmuting was successful\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !await this.client.getMediaHandler().hasAudioDevice()) {\n            return false;\n        }\n\n        const sendUpdatesBefore = !muted && this.isPtt;\n\n        // set a timer for the maximum transmit time on PTT calls\n        if (this.isPtt) {\n            // Set or clear the max transmit timer\n            if (!muted && this.isMicrophoneMuted()) {\n                this.transmitTimer = setTimeout(() => {\n                    this.setMicrophoneMuted(true);\n                }, this.pttMaxTransmitTime);\n            } else if (muted && !this.isMicrophoneMuted()) {\n                if (this.transmitTimer !== null) clearTimeout(this.transmitTimer);\n                this.transmitTimer = null;\n            }\n        }\n\n        this.forEachCall(call => call.localUsermediaFeed?.setAudioVideoMuted(muted, null));\n\n        const sendUpdates = async (): Promise<void> => {\n            const updates: Promise<void>[] = [];\n            this.forEachCall(call => updates.push(call.sendMetadataUpdate()));\n\n            await Promise.all(updates).catch(\n                e => logger.info(\"Failed to send some metadata updates\", e),\n            );\n        };\n\n        if (sendUpdatesBefore) await sendUpdates();\n\n        if (this.localCallFeed) {\n            logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted stream ${\n                this.localCallFeed.stream.id} muted ${muted}`);\n            this.localCallFeed.setAudioVideoMuted(muted, null);\n            // I don't believe its actually necessary to enable these tracks: they\n            // are the one on the groupcall's own CallFeed and are cloned before being\n            // given to any of the actual calls, so these tracks don't actually go\n            // anywhere. Let's do it anyway to avoid confusion.\n            setTracksEnabled(this.localCallFeed.stream.getAudioTracks(), !muted);\n        } else {\n            logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted no stream muted ${muted}`);\n            this.initWithAudioMuted = muted;\n        }\n\n        this.forEachCall(call => setTracksEnabled(call.localUsermediaFeed!.stream.getAudioTracks(), !muted));\n        this.emit(GroupCallEvent.LocalMuteStateChanged, muted, this.isLocalVideoMuted());\n\n        if (!sendUpdatesBefore) await sendUpdates();\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's video.\n     * @param {boolean} muted Whether to mute the video\n     * @returns {Promise<boolean>} Whether muting/unmuting was successful\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !await this.client.getMediaHandler().hasVideoDevice()) {\n            return false;\n        }\n\n        if (this.localCallFeed) {\n            logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted stream ${\n                this.localCallFeed.stream.id} muted ${muted}`);\n            this.localCallFeed.setAudioVideoMuted(null, muted);\n            setTracksEnabled(this.localCallFeed.stream.getVideoTracks(), !muted);\n        } else {\n            logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted no stream muted ${muted}`);\n            this.initWithVideoMuted = muted;\n        }\n\n        const updates: Promise<unknown>[] = [];\n        this.forEachCall(call => updates.push(call.setLocalVideoMuted(muted)));\n        await Promise.all(updates);\n\n        this.emit(GroupCallEvent.LocalMuteStateChanged, this.isMicrophoneMuted(), muted);\n\n        return true;\n    }\n\n    public async setScreensharingEnabled(\n        enabled: boolean, opts: IScreensharingOpts = {},\n    ): Promise<boolean> {\n        if (enabled === this.isScreensharing()) {\n            return enabled;\n        }\n\n        if (enabled) {\n            try {\n                logger.log(\"Asking for screensharing permissions...\");\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n\n                for (const track of stream.getTracks()) {\n                    const onTrackEnded = (): void => {\n                        this.setScreensharingEnabled(false);\n                        track.removeEventListener(\"ended\", onTrackEnded);\n                    };\n\n                    track.addEventListener(\"ended\", onTrackEnded);\n                }\n\n                logger.log(\"Screensharing permissions granted. Setting screensharing enabled on all calls\");\n\n                this.localDesktopCapturerSourceId = opts.desktopCapturerSourceId;\n                this.localScreenshareFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.room.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId()!,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Screenshare,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n                this.addScreenshareFeed(this.localScreenshareFeed);\n\n                this.emit(\n                    GroupCallEvent.LocalScreenshareStateChanged,\n                    true,\n                    this.localScreenshareFeed,\n                    this.localDesktopCapturerSourceId,\n                );\n\n                // TODO: handle errors\n                this.forEachCall(call => call.pushLocalFeed(this.localScreenshareFeed!.clone()));\n\n                return true;\n            } catch (error) {\n                if (opts.throwOnFail) throw error;\n                logger.error(\"Enabling screensharing error\", error);\n                this.emit(GroupCallEvent.Error,\n                    new GroupCallError(\n                        GroupCallErrorCode.NoUserMedia,\n                        \"Failed to get screen-sharing stream: \", error as Error,\n                    ),\n                );\n                return false;\n            }\n        } else {\n            this.forEachCall(call => {\n                if (call.localScreensharingFeed) call.removeLocalFeed(call.localScreensharingFeed);\n            });\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed!.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed!);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n            this.emit(GroupCallEvent.LocalScreenshareStateChanged, false, undefined, undefined);\n            return false;\n        }\n    }\n\n    public isScreensharing(): boolean {\n        return !!this.localScreenshareFeed;\n    }\n\n    /*\n     * Call Setup\n     *\n     * There are two different paths for calls to be created:\n     * 1. Incoming calls triggered by the Call.incoming event.\n     * 2. Outgoing calls to the initial members of a room or new members\n     *    as they are observed by the RoomState.members event.\n     */\n\n    private onIncomingCall = (newCall: MatrixCall): void => {\n        // The incoming calls may be for another room, which we will ignore.\n        if (newCall.roomId !== this.room.roomId) {\n            return;\n        }\n\n        if (newCall.state !== CallState.Ringing) {\n            logger.warn(\"Incoming call no longer in ringing state. Ignoring.\");\n            return;\n        }\n\n        if (!newCall.groupCallId || newCall.groupCallId !== this.groupCallId) {\n            logger.log(`Incoming call with groupCallId ${\n                newCall.groupCallId} ignored because it doesn't match the current group call`);\n            newCall.reject();\n            return;\n        }\n\n        const opponent = newCall.getOpponentMember();\n        if (opponent === undefined) {\n            logger.warn(\"Incoming call with no member. Ignoring.\");\n            return;\n        }\n\n        const deviceMap = this.calls.get(opponent) ?? new Map<string, MatrixCall>();\n        const prevCall = deviceMap.get(newCall.getOpponentDeviceId()!);\n\n        if (prevCall?.callId === newCall.callId) return;\n\n        logger.log(`GroupCall: incoming call from ${opponent.userId} with ID ${newCall.callId}`);\n\n        if (prevCall) this.disposeCall(prevCall, CallErrorCode.Replaced);\n\n        this.initCall(newCall);\n        newCall.answerWithCallFeeds(this.getLocalFeeds().map((feed) => feed.clone()));\n\n        deviceMap.set(newCall.getOpponentDeviceId()!, newCall);\n        this.calls.set(opponent, deviceMap);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /**\n     * Determines whether a given participant expects us to call them (versus\n     * them calling us).\n     * @param userId The participant's user ID.\n     * @param deviceId The participant's device ID.\n     * @returns Whether we need to place an outgoing call to the participant.\n     */\n    private wantsOutgoingCall(userId: string, deviceId: string): boolean {\n        const localUserId = this.client.getUserId()!;\n        const localDeviceId = this.client.getDeviceId()!;\n        return (\n            // If a user's ID is less than our own, they'll call us\n            userId >= localUserId\n            // If this is another one of our devices, compare device IDs to tell whether it'll call us\n            && (userId !== localUserId || deviceId > localDeviceId)\n        );\n    }\n\n    /**\n     * Places calls to all participants that we're responsible for calling.\n     */\n    private placeOutgoingCalls(): void {\n        let callsChanged = false;\n\n        for (const [member, participantMap] of this.participants) {\n            const callMap = this.calls.get(member) ?? new Map<string, MatrixCall>();\n\n            for (const [deviceId, participant] of participantMap) {\n                const prevCall = callMap.get(deviceId);\n\n                if (\n                    prevCall?.getOpponentSessionId() !== participant.sessionId\n                    && this.wantsOutgoingCall(member.userId, deviceId)\n                ) {\n                    callsChanged = true;\n\n                    if (prevCall !== undefined) {\n                        logger.debug(`Replacing call ${prevCall.callId} to ${member.userId} ${deviceId}`);\n                        this.disposeCall(prevCall, CallErrorCode.NewSession);\n                    }\n\n                    const newCall = createNewMatrixCall(\n                        this.client,\n                        this.room.roomId,\n                        {\n                            invitee: member.userId,\n                            opponentDeviceId: deviceId,\n                            opponentSessionId: participant.sessionId,\n                            groupCallId: this.groupCallId,\n                        },\n                    );\n\n                    if (newCall === null) {\n                        logger.error(`Failed to create call with ${member.userId} ${deviceId}`);\n                        callMap.delete(deviceId);\n                    } else {\n                        this.initCall(newCall);\n                        callMap.set(deviceId, newCall);\n\n                        logger.debug(\n                            `Placing call to ${member.userId} ${deviceId} (session ${participant.sessionId})`,\n                        );\n\n                        newCall.placeCallWithCallFeeds(\n                            this.getLocalFeeds().map(feed => feed.clone()),\n                            participant.screensharing,\n                        ).then(() => {\n                            if (this.dataChannelsEnabled) {\n                                newCall.createDataChannel(\"datachannel\", this.dataChannelOptions);\n                            }\n                        }).catch(e => {\n                            logger.warn(`Failed to place call to ${member.userId}`, e);\n\n                            if (e instanceof CallError && e.code === GroupCallErrorCode.UnknownDevice) {\n                                this.emit(GroupCallEvent.Error, e);\n                            } else {\n                                this.emit(\n                                    GroupCallEvent.Error,\n                                    new GroupCallError(\n                                        GroupCallErrorCode.PlaceCallFailed,\n                                        `Failed to place call to ${member.userId}`,\n                                    ),\n                                );\n                            }\n\n                            this.disposeCall(newCall, CallErrorCode.SignallingFailed);\n                            if (callMap.get(deviceId) === newCall) callMap.delete(deviceId);\n                        });\n                    }\n                }\n            }\n\n            if (callMap.size > 0) {\n                this.calls.set(member, callMap);\n            } else {\n                this.calls.delete(member);\n            }\n        }\n\n        if (callsChanged) this.emit(GroupCallEvent.CallsChanged, this.calls);\n    }\n\n    /*\n     * Room Member State\n     */\n\n    private getMemberStateEvents(): MatrixEvent[];\n    private getMemberStateEvents(userId: string): MatrixEvent | null;\n    private getMemberStateEvents(userId?: string): MatrixEvent[] | MatrixEvent | null {\n        return userId === undefined\n            ? this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix)\n            : this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix, userId);\n    }\n\n    private onRetryCallLoop = (): void => {\n        let needsRetry = false;\n\n        for (const [member, participantMap] of this.participants) {\n            const callMap = this.calls.get(member);\n            let retriesMap = this.retryCallCounts.get(member);\n\n            for (const [deviceId, participant] of participantMap) {\n                const call = callMap?.get(deviceId);\n                const retries = retriesMap?.get(deviceId) ?? 0;\n\n                if (\n                    call?.getOpponentSessionId() !== participant.sessionId\n                    && this.wantsOutgoingCall(member.userId, deviceId)\n                    && retries < 3\n                ) {\n                    if (retriesMap === undefined) {\n                        retriesMap = new Map();\n                        this.retryCallCounts.set(member, retriesMap);\n                    }\n                    retriesMap.set(deviceId, retries + 1);\n                    needsRetry = true;\n                }\n            }\n        }\n\n        if (needsRetry) this.placeOutgoingCalls();\n    };\n\n    private initCall(call: MatrixCall): void {\n        const opponentMemberId = getCallUserId(call);\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot init call without user id\");\n        }\n\n        const onCallFeedsChanged = (): void => this.onCallFeedsChanged(call);\n        const onCallStateChanged = (\n            state: CallState,\n            oldState?: CallState,\n        ): void => this.onCallStateChanged(call, state, oldState);\n        const onCallHangup = this.onCallHangup;\n        const onCallReplaced = (newCall: MatrixCall): void => this.onCallReplaced(call, newCall);\n\n        let deviceMap = this.callHandlers.get(opponentMemberId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.callHandlers.set(opponentMemberId, deviceMap);\n        }\n\n        deviceMap.set(call.getOpponentDeviceId()!, {\n            onCallFeedsChanged,\n            onCallStateChanged,\n            onCallHangup,\n            onCallReplaced,\n        });\n\n        call.on(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.on(CallEvent.State, onCallStateChanged);\n        call.on(CallEvent.Hangup, onCallHangup);\n        call.on(CallEvent.Replaced, onCallReplaced);\n\n        call.isPtt = this.isPtt;\n\n        this.reEmitter.reEmit(call, Object.values(CallEvent));\n\n        onCallFeedsChanged();\n    }\n\n    private disposeCall(call: MatrixCall, hangupReason: CallErrorCode): void {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot dispose call without user id\");\n        }\n\n        const deviceMap = this.callHandlers.get(opponentMemberId)!;\n        const {\n            onCallFeedsChanged,\n            onCallStateChanged,\n            onCallHangup,\n            onCallReplaced,\n        } = deviceMap.get(opponentDeviceId)!;\n\n        call.removeListener(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.removeListener(CallEvent.State, onCallStateChanged);\n        call.removeListener(CallEvent.Hangup, onCallHangup);\n        call.removeListener(CallEvent.Replaced, onCallReplaced);\n\n        deviceMap.delete(opponentMemberId);\n        if (deviceMap.size === 0) this.callHandlers.delete(opponentMemberId);\n\n        if (call.hangupReason === CallErrorCode.Replaced) {\n            return;\n        }\n\n        if (call.state !== CallState.Ended) {\n            call.hangup(hangupReason, false);\n        }\n\n        const usermediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n\n        if (usermediaFeed) {\n            this.removeUserMediaFeed(usermediaFeed);\n        }\n\n        const screenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n\n        if (screenshareFeed) {\n            this.removeScreenshareFeed(screenshareFeed);\n        }\n    }\n\n    private onCallFeedsChanged = (call: MatrixCall): void => {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot change call feeds without user id\");\n        }\n\n        const currentUserMediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n        const remoteUsermediaFeed = call.remoteUsermediaFeed;\n        const remoteFeedChanged = remoteUsermediaFeed !== currentUserMediaFeed;\n\n        if (remoteFeedChanged) {\n            if (!currentUserMediaFeed && remoteUsermediaFeed) {\n                this.addUserMediaFeed(remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && remoteUsermediaFeed) {\n                this.replaceUserMediaFeed(currentUserMediaFeed, remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && !remoteUsermediaFeed) {\n                this.removeUserMediaFeed(currentUserMediaFeed);\n            }\n        }\n\n        const currentScreenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n        const remoteScreensharingFeed = call.remoteScreensharingFeed;\n        const remoteScreenshareFeedChanged = remoteScreensharingFeed !== currentScreenshareFeed;\n\n        if (remoteScreenshareFeedChanged) {\n            if (!currentScreenshareFeed && remoteScreensharingFeed) {\n                this.addScreenshareFeed(remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && remoteScreensharingFeed) {\n                this.replaceScreenshareFeed(currentScreenshareFeed, remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && !remoteScreensharingFeed) {\n                this.removeScreenshareFeed(currentScreenshareFeed);\n            }\n        }\n    };\n\n    private onCallStateChanged = (call: MatrixCall, state: CallState, _oldState: CallState | undefined): void => {\n        const audioMuted = this.localCallFeed!.isAudioMuted();\n\n        if (\n            call.localUsermediaStream &&\n            call.isMicrophoneMuted() !== audioMuted\n        ) {\n            call.setMicrophoneMuted(audioMuted);\n        }\n\n        const videoMuted = this.localCallFeed!.isVideoMuted();\n\n        if (\n            call.localUsermediaStream &&\n            call.isLocalVideoMuted() !== videoMuted\n        ) {\n            call.setLocalVideoMuted(videoMuted);\n        }\n\n        if (state === CallState.Connected) {\n            const opponent = call.getOpponentMember()!;\n            const retriesMap = this.retryCallCounts.get(opponent);\n            retriesMap?.delete(call.getOpponentDeviceId()!);\n            if (retriesMap?.size === 0) this.retryCallCounts.delete(opponent);\n        }\n    };\n\n    private onCallHangup = (call: MatrixCall): void => {\n        if (call.hangupReason === CallErrorCode.Replaced) return;\n\n        const opponent = call.getOpponentMember() ?? this.room.getMember(call.invitee!)!;\n        const deviceMap = this.calls.get(opponent);\n\n        // Sanity check that this call is in fact in the map\n        if (deviceMap?.get(call.getOpponentDeviceId()!) === call) {\n            this.disposeCall(call, call.hangupReason as CallErrorCode);\n            deviceMap.delete(call.getOpponentDeviceId()!);\n            if (deviceMap.size === 0) this.calls.delete(opponent);\n            this.emit(GroupCallEvent.CallsChanged, this.calls);\n        }\n    };\n\n    private onCallReplaced = (prevCall: MatrixCall, newCall: MatrixCall): void => {\n        const opponent = prevCall.getOpponentMember()!;\n\n        let deviceMap = this.calls.get(opponent);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.calls.set(opponent, deviceMap);\n        }\n\n        this.disposeCall(prevCall, CallErrorCode.Replaced);\n        this.initCall(newCall);\n        deviceMap.set(prevCall.getOpponentDeviceId()!, newCall);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /*\n     * UserMedia CallFeed Event Handlers\n     */\n\n    public getUserMediaFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.userMediaFeeds.find(f => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addUserMediaFeed(callFeed: CallFeed): void {\n        this.userMediaFeeds.push(callFeed);\n        callFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private replaceUserMediaFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            f => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to replace\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        replacementFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private removeUserMediaFeed(callFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            f => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to remove\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n\n        if (this.activeSpeaker === callFeed) {\n            this.activeSpeaker = this.userMediaFeeds[0];\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    }\n\n    private onActiveSpeakerLoop = (): void => {\n        let topAvg: number | undefined = undefined;\n        let nextActiveSpeaker: CallFeed | undefined = undefined;\n\n        for (const callFeed of this.userMediaFeeds) {\n            if (callFeed.isLocal() && this.userMediaFeeds.length > 1) continue;\n\n            const total = callFeed.speakingVolumeSamples.reduce(\n                (acc, volume) => acc + Math.max(volume, SPEAKING_THRESHOLD),\n            );\n            const avg = total / callFeed.speakingVolumeSamples.length;\n\n            if (!topAvg || avg > topAvg) {\n                topAvg = avg;\n                nextActiveSpeaker = callFeed;\n            }\n        }\n\n        if (nextActiveSpeaker && this.activeSpeaker !== nextActiveSpeaker && topAvg && topAvg > SPEAKING_THRESHOLD) {\n            this.activeSpeaker = nextActiveSpeaker;\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    };\n\n    /*\n     * Screenshare Call Feed Event Handlers\n     */\n\n    public getScreenshareFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.screenshareFeeds.find(f => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addScreenshareFeed(callFeed: CallFeed): void {\n        this.screenshareFeeds.push(callFeed);\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private replaceScreenshareFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            f => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to replace\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private removeScreenshareFeed(callFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            f => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to remove\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    /**\n     * Recalculates and updates the participant map to match the room state.\n     */\n    private updateParticipants(): void {\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state === GroupCallState.Ended) {\n            this.participants = new Map();\n            return;\n        }\n\n        const participants = new Map<RoomMember, Map<string, ParticipantState>>();\n        const now = Date.now();\n        const entered = this.state === GroupCallState.Entered || this.enteredViaAnotherSession;\n        let nextExpiration = Infinity;\n\n        for (const e of this.getMemberStateEvents()) {\n            const member = this.room.getMember(e.getStateKey()!);\n            const content = e.getContent<Record<any, unknown>>();\n            const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n            const call = calls.find(call => call[\"m.call_id\"] === this.groupCallId);\n            const devices: Record<any, unknown>[] = Array.isArray(call?.[\"m.devices\"]) ? call![\"m.devices\"] : [];\n\n            // Filter out invalid and expired devices\n            let validDevices = devices.filter(d => (\n                typeof d.device_id === \"string\"\n                && typeof d.session_id === \"string\"\n                && typeof d.expires_ts === \"number\"\n                && d.expires_ts > now\n                && Array.isArray(d.feeds)\n            )) as unknown as IGroupCallRoomMemberDevice[];\n\n            // Apply local echo for the unentered case\n            if (!entered && member?.userId === this.client.getUserId()!) {\n                validDevices = validDevices.filter(d => d.device_id !== this.client.getDeviceId()!);\n            }\n\n            // Must have a connected device and be joined to the room\n            if (validDevices.length > 0 && member?.membership === \"join\") {\n                const deviceMap = new Map<string, ParticipantState>();\n                participants.set(member, deviceMap);\n\n                for (const d of validDevices) {\n                    deviceMap.set(d.device_id, {\n                        sessionId: d.session_id,\n                        screensharing: d.feeds.some(f => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                    });\n                    if (d.expires_ts < nextExpiration) nextExpiration = d.expires_ts;\n                }\n            }\n        }\n\n        // Apply local echo for the entered case\n        if (entered) {\n            const localMember = this.room.getMember(this.client.getUserId()!)!;\n            let deviceMap = participants.get(localMember);\n            if (deviceMap === undefined) {\n                deviceMap = new Map();\n                participants.set(localMember, deviceMap);\n            }\n\n            if (!deviceMap.has(this.client.getDeviceId()!)) {\n                deviceMap.set(this.client.getDeviceId()!, {\n                    sessionId: this.client.getSessionId(),\n                    screensharing: this.getLocalFeeds().some(f => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                });\n            }\n        }\n\n        this.participants = participants;\n        if (nextExpiration < Infinity) {\n            this.participantsExpirationTimer = setTimeout(() => this.updateParticipants(), nextExpiration - now);\n        }\n    }\n\n    /**\n     * Updates the local user's member state with the devices returned by the given function.\n     * @param fn A function from the current devices to the new devices. If it\n     *   returns null, the update will be skipped.\n     * @param keepAlive Whether the request should outlive the window.\n     */\n    private async updateDevices(\n        fn: (devices: IGroupCallRoomMemberDevice[]) => IGroupCallRoomMemberDevice[] | null,\n        keepAlive = false,\n    ): Promise<void> {\n        const now = Date.now();\n        const localUserId = this.client.getUserId()!;\n\n        const event = this.getMemberStateEvents(localUserId);\n        const content = event?.getContent<Record<any, unknown>>() ?? {};\n        const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n\n        let call: Record<any, unknown> | null = null;\n        const otherCalls: Record<any, unknown>[] = [];\n        for (const c of calls) {\n            if (c[\"m.call_id\"] === this.groupCallId) {\n                call = c;\n            } else {\n                otherCalls.push(c);\n            }\n        }\n        if (call === null) call = {};\n\n        const devices: Record<any, unknown>[] = Array.isArray(call[\"m.devices\"]) ? call[\"m.devices\"] : [];\n\n        // Filter out invalid and expired devices\n        const validDevices = devices.filter(d => (\n            typeof d.device_id === \"string\"\n            && typeof d.session_id === \"string\"\n            && typeof d.expires_ts === \"number\"\n            && d.expires_ts > now\n            && Array.isArray(d.feeds)\n        )) as unknown as IGroupCallRoomMemberDevice[];\n\n        const newDevices = fn(validDevices);\n        if (newDevices === null) return;\n\n        const newCalls = [...otherCalls as unknown as IGroupCallRoomMemberCallState[]];\n        if (newDevices.length > 0) {\n            newCalls.push({\n                ...call,\n                \"m.call_id\": this.groupCallId,\n                \"m.devices\": newDevices,\n            });\n        }\n\n        const newContent: IGroupCallRoomMemberState = { \"m.calls\": newCalls };\n\n        await this.client.sendStateEvent(\n            this.room.roomId, EventType.GroupCallMemberPrefix, newContent, localUserId, { keepAlive },\n        );\n    }\n\n    private async addDeviceToMemberState(): Promise<void> {\n        await this.updateDevices(devices => [\n            ...devices.filter(d => d.device_id !== this.client.getDeviceId()!),\n            {\n                \"device_id\": this.client.getDeviceId()!,\n                \"session_id\": this.client.getSessionId(),\n                \"expires_ts\": Date.now() + DEVICE_TIMEOUT,\n                \"feeds\": this.getLocalFeeds().map(feed => ({ purpose: feed.purpose })),\n                // TODO: Add data channels\n            },\n        ]);\n    }\n\n    private async updateMemberState(): Promise<void> {\n        // Clear the old update interval before proceeding\n        if (this.resendMemberStateTimer !== null) {\n            clearInterval(this.resendMemberStateTimer);\n            this.resendMemberStateTimer = null;\n        }\n\n        if (this.state === GroupCallState.Entered) {\n            // Add the local device\n            await this.addDeviceToMemberState();\n\n            // Resend the state event every so often so it doesn't become stale\n            this.resendMemberStateTimer = setInterval(async () => {\n                logger.log(\"Resending call member state\");\n                try {\n                    await this.addDeviceToMemberState();\n                } catch (e) {\n                    logger.error(\"Failed to resend call member state\", e);\n                }\n            }, DEVICE_TIMEOUT * 3 / 4);\n        } else {\n            // Remove the local device\n            await this.updateDevices(\n                devices => devices.filter(d => d.device_id !== this.client.getDeviceId()!),\n                true,\n            );\n        }\n    }\n\n    /**\n     * Cleans up our member state by filtering out logged out devices, inactive\n     * devices, and our own device (if we know we haven't entered).\n     */\n    public async cleanMemberState(): Promise<void> {\n        const { devices: myDevices } = await this.client.getDevices();\n        const deviceMap = new Map<string, IMyDevice>(myDevices.map(d => [d.device_id, d]));\n\n        // updateDevices takes care of filtering out inactive devices for us\n        await this.updateDevices(devices => {\n            const newDevices = devices.filter(d => {\n                const device = deviceMap.get(d.device_id);\n                return device?.last_seen_ts !== undefined && !(\n                    d.device_id === this.client.getDeviceId()!\n                    && this.state !== GroupCallState.Entered\n                    && !this.enteredViaAnotherSession\n                );\n            });\n\n            // Skip the update if the devices are unchanged\n            return newDevices.length === devices.length ? null : newDevices;\n        });\n    }\n\n    private onRoomState = (): void => this.updateParticipants();\n\n    private onParticipantsChanged = (): void => {\n        if (this.state === GroupCallState.Entered) this.placeOutgoingCalls();\n    };\n\n    private onStateChanged = (newState: GroupCallState, oldState: GroupCallState): void => {\n        if (\n            newState === GroupCallState.Entered\n            || oldState === GroupCallState.Entered\n            || newState === GroupCallState.Ended\n        ) {\n            // We either entered, left, or ended the call\n            this.updateParticipants();\n            this.updateMemberState().catch(e => logger.error(\"Failed to update member state devices\", e));\n        }\n    };\n\n    private onLocalFeedsChanged = (): void => {\n        if (this.state === GroupCallState.Entered) {\n            this.updateMemberState().catch(e => logger.error(\"Failed to update member state feeds\", e));\n        }\n    };\n}\n"],"mappings":"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"}