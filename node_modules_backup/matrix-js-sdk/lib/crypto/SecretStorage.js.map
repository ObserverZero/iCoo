{"version":3,"file":"SecretStorage.js","names":["SECRET_STORAGE_ALGORITHM_V1_AES","SecretStorage","constructor","accountDataAdapter","cryptoCallbacks","baseApis","Map","getDefaultKeyId","defaultKey","getAccountDataFromServer","key","setDefaultKeyId","keyId","Promise","resolve","reject","listener","ev","getType","getContent","removeListener","ClientEvent","AccountData","on","setAccountData","catch","e","addKey","algorithm","opts","keyInfo","name","passphrase","iv","mac","calculateKeyCheck","Error","randomString","getKey","hasKey","Boolean","checkKey","info","replace","store","secret","keys","encrypted","defaultKeyId","length","encryption","getSecretStorageKey","encrypt","logger","warn","get","secretInfo","Object","encInfo","ciphertext","decryption","passthrough","encodeBase64","get_private_key","decrypt","free","isStored","ret","request","devices","requestId","makeTxnId","deferred","defer","requests","set","cancel","reason","cancelData","action","requesting_device_id","deviceId","request_id","toDevice","device","sendToDevice","getUserId","requestData","promise","onRequestReceived","event","sender","getSender","content","onSecretRequested","checkDeviceTrust","payload","type","encryptedContent","olmlib","OLM_ALGORITHM","sender_key","crypto","olmDevice","deviceCurve25519Key","ensureOlmSessionsForDevices","getStoredDevice","encryptMessageForDevice","contentMap","onSecretReceived","isOlmEncrypted","error","senderKeyUser","deviceList","getUserByIdentityKey","getSenderKey","log","requestControl","deviceInfo","getDeviceByIdentityKey","includes","deviceTrust","checkDeviceInfoTrust","isVerified","returned","privateKey","encryptAES","decryptAES"],"sources":["../../src/crypto/SecretStorage.ts"],"sourcesContent":["/*\nCopyright 2019 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from '../logger';\nimport * as olmlib from './olmlib';\nimport { encodeBase64 } from './olmlib';\nimport { randomString } from '../randomstring';\nimport { calculateKeyCheck, decryptAES, encryptAES, IEncryptedPayload } from './aes';\nimport { ICryptoCallbacks } from \".\";\nimport { IContent, MatrixEvent } from \"../models/event\";\nimport { ClientEvent, ClientEventHandlerMap, MatrixClient } from \"../client\";\nimport { IAddSecretStorageKeyOpts, ISecretStorageKeyInfo } from './api';\nimport { TypedEventEmitter } from '../models/typed-event-emitter';\nimport { defer, IDeferred } from \"../utils\";\n\nexport const SECRET_STORAGE_ALGORITHM_V1_AES = \"m.secret_storage.v1.aes-hmac-sha2\";\n\n// Some of the key functions use a tuple and some use an object...\nexport type SecretStorageKeyTuple = [keyId: string, keyInfo: ISecretStorageKeyInfo];\nexport type SecretStorageKeyObject = {keyId: string, keyInfo: ISecretStorageKeyInfo};\n\nexport interface ISecretRequest {\n    requestId: string;\n    promise: Promise<string>;\n    cancel: (reason: string) => void;\n}\n\nexport interface IAccountDataClient extends TypedEventEmitter<ClientEvent.AccountData, ClientEventHandlerMap> {\n    // Subset of MatrixClient (which also uses any for the event content)\n    getAccountDataFromServer: <T extends {[k: string]: any}>(eventType: string) => Promise<T>;\n    getAccountData: (eventType: string) => IContent | null;\n    setAccountData: (eventType: string, content: any) => Promise<{}>;\n}\n\ninterface ISecretRequestInternal {\n    name: string;\n    devices: string[];\n    deferred: IDeferred<string>;\n}\n\ninterface IDecryptors {\n    encrypt: (plaintext: string) => Promise<IEncryptedPayload>;\n    decrypt: (ciphertext: IEncryptedPayload) => Promise<string>;\n}\n\ninterface ISecretInfo {\n    encrypted: {\n        // eslint-disable-next-line camelcase\n        key_id: IEncryptedPayload;\n    };\n}\n\n/**\n * Implements Secure Secret Storage and Sharing (MSC1946)\n * @module crypto/SecretStorage\n */\nexport class SecretStorage<B extends MatrixClient | undefined = MatrixClient> {\n    private requests = new Map<string, ISecretRequestInternal>();\n\n    // In it's pure javascript days, this was relying on some proper Javascript-style\n    // type-abuse where sometimes we'd pass in a fake client object with just the account\n    // data methods implemented, which is all this class needs unless you use the secret\n    // sharing code, so it was fine. As a low-touch TypeScript migration, this now has\n    // an extra, optional param for a real matrix client, so you can not pass it as long\n    // as you don't request any secrets.\n    // A better solution would probably be to split this class up into secret storage and\n    // secret sharing which are really two separate things, even though they share an MSC.\n    public constructor(\n        private readonly accountDataAdapter: IAccountDataClient,\n        private readonly cryptoCallbacks: ICryptoCallbacks,\n        private readonly baseApis: B,\n    ) {}\n\n    public async getDefaultKeyId(): Promise<string | null> {\n        const defaultKey = await this.accountDataAdapter.getAccountDataFromServer<{ key: string }>(\n            'm.secret_storage.default_key',\n        );\n        if (!defaultKey) return null;\n        return defaultKey.key;\n    }\n\n    public setDefaultKeyId(keyId: string): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            const listener = (ev: MatrixEvent): void => {\n                if (\n                    ev.getType() === 'm.secret_storage.default_key' &&\n                    ev.getContent().key === keyId\n                ) {\n                    this.accountDataAdapter.removeListener(ClientEvent.AccountData, listener);\n                    resolve();\n                }\n            };\n            this.accountDataAdapter.on(ClientEvent.AccountData, listener);\n\n            this.accountDataAdapter.setAccountData(\n                'm.secret_storage.default_key',\n                { key: keyId },\n            ).catch(e => {\n                this.accountDataAdapter.removeListener(ClientEvent.AccountData, listener);\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Add a key for encrypting secrets.\n     *\n     * @param {string} algorithm the algorithm used by the key.\n     * @param {object} opts the options for the algorithm.  The properties used\n     *     depend on the algorithm given.\n     * @param {string} [keyId] the ID of the key.  If not given, a random\n     *     ID will be generated.\n     *\n     * @return {object} An object with:\n     *     keyId: {string} the ID of the key\n     *     keyInfo: {object} details about the key (iv, mac, passphrase)\n     */\n    public async addKey(\n        algorithm: string,\n        opts: IAddSecretStorageKeyOpts = {},\n        keyId?: string,\n    ): Promise<SecretStorageKeyObject> {\n        const keyInfo = { algorithm } as ISecretStorageKeyInfo;\n\n        if (opts.name) {\n            keyInfo.name = opts.name;\n        }\n\n        if (algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n            if (opts.passphrase) {\n                keyInfo.passphrase = opts.passphrase;\n            }\n            if (opts.key) {\n                const { iv, mac } = await calculateKeyCheck(opts.key);\n                keyInfo.iv = iv;\n                keyInfo.mac = mac;\n            }\n        } else {\n            throw new Error(`Unknown key algorithm ${algorithm}`);\n        }\n\n        if (!keyId) {\n            do {\n                keyId = randomString(32);\n            } while (\n                await this.accountDataAdapter.getAccountDataFromServer<ISecretStorageKeyInfo>(\n                    `m.secret_storage.key.${keyId}`,\n                )\n            );\n        }\n\n        await this.accountDataAdapter.setAccountData(\n            `m.secret_storage.key.${keyId}`, keyInfo,\n        );\n\n        return {\n            keyId,\n            keyInfo,\n        };\n    }\n\n    /**\n     * Get the key information for a given ID.\n     *\n     * @param {string} [keyId = default key's ID] The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @returns {Array?} If the key was found, the return value is an array of\n     *     the form [keyId, keyInfo].  Otherwise, null is returned.\n     *     XXX: why is this an array when addKey returns an object?\n     */\n    public async getKey(keyId?: string | null): Promise<SecretStorageKeyTuple | null> {\n        if (!keyId) {\n            keyId = await this.getDefaultKeyId();\n        }\n        if (!keyId) {\n            return null;\n        }\n\n        const keyInfo = await this.accountDataAdapter.getAccountDataFromServer<ISecretStorageKeyInfo>(\n            \"m.secret_storage.key.\" + keyId,\n        );\n        return keyInfo ? [keyId, keyInfo] : null;\n    }\n\n    /**\n     * Check whether we have a key with a given ID.\n     *\n     * @param {string} [keyId = default key's ID] The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @return {boolean} Whether we have the key.\n     */\n    public async hasKey(keyId?: string): Promise<boolean> {\n        return Boolean(await this.getKey(keyId));\n    }\n\n    /**\n     * Check whether a key matches what we expect based on the key info\n     *\n     * @param {Uint8Array} key the key to check\n     * @param {object} info the key info\n     *\n     * @return {boolean} whether or not the key matches\n     */\n    public async checkKey(key: Uint8Array, info: ISecretStorageKeyInfo): Promise<boolean> {\n        if (info.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n            if (info.mac) {\n                const { mac } = await calculateKeyCheck(key, info.iv);\n                return info.mac.replace(/=+$/g, '') === mac.replace(/=+$/g, '');\n            } else {\n                // if we have no information, we have to assume the key is right\n                return true;\n            }\n        } else {\n            throw new Error(\"Unknown algorithm\");\n        }\n    }\n\n    /**\n     * Store an encrypted secret on the server\n     *\n     * @param {string} name The name of the secret\n     * @param {string} secret The secret contents.\n     * @param {Array} keys The IDs of the keys to use to encrypt the secret\n     *     or null/undefined to use the default key.\n     */\n    public async store(name: string, secret: string, keys?: string[] | null): Promise<void> {\n        const encrypted: Record<string, IEncryptedPayload> = {};\n\n        if (!keys) {\n            const defaultKeyId = await this.getDefaultKeyId();\n            if (!defaultKeyId) {\n                throw new Error(\"No keys specified and no default key present\");\n            }\n            keys = [defaultKeyId];\n        }\n\n        if (keys.length === 0) {\n            throw new Error(\"Zero keys given to encrypt with!\");\n        }\n\n        for (const keyId of keys) {\n            // get key information from key storage\n            const keyInfo = await this.accountDataAdapter.getAccountDataFromServer<ISecretStorageKeyInfo>(\n                \"m.secret_storage.key.\" + keyId,\n            );\n            if (!keyInfo) {\n                throw new Error(\"Unknown key: \" + keyId);\n            }\n\n            // encrypt secret, based on the algorithm\n            if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                const keys = { [keyId]: keyInfo };\n                const [, encryption] = await this.getSecretStorageKey(keys, name);\n                encrypted[keyId] = await encryption.encrypt(secret);\n            } else {\n                logger.warn(\"unknown algorithm for secret storage key \" + keyId\n                            + \": \" + keyInfo.algorithm);\n                // do nothing if we don't understand the encryption algorithm\n            }\n        }\n\n        // save encrypted secret\n        await this.accountDataAdapter.setAccountData(name, { encrypted });\n    }\n\n    /**\n     * Get a secret from storage.\n     *\n     * @param {string} name the name of the secret\n     *\n     * @return {string} the contents of the secret\n     */\n    public async get(name: string): Promise<string | undefined> {\n        const secretInfo = await this.accountDataAdapter.getAccountDataFromServer<ISecretInfo>(name);\n        if (!secretInfo) {\n            return;\n        }\n        if (!secretInfo.encrypted) {\n            throw new Error(\"Content is not encrypted!\");\n        }\n\n        // get possible keys to decrypt\n        const keys: Record<string, ISecretStorageKeyInfo> = {};\n        for (const keyId of Object.keys(secretInfo.encrypted)) {\n            // get key information from key storage\n            const keyInfo = (\n                await this.accountDataAdapter.getAccountDataFromServer<ISecretStorageKeyInfo>(\n                    \"m.secret_storage.key.\" + keyId,\n                )\n            );\n            const encInfo = secretInfo.encrypted[keyId];\n            // only use keys we understand the encryption algorithm of\n            if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {\n                    keys[keyId] = keyInfo;\n                }\n            }\n        }\n\n        if (Object.keys(keys).length === 0) {\n            throw new Error(`Could not decrypt ${name} because none of ` +\n                `the keys it is encrypted with are for a supported algorithm`);\n        }\n\n        let keyId: string;\n        let decryption;\n        try {\n            // fetch private key from app\n            [keyId, decryption] = await this.getSecretStorageKey(keys, name);\n\n            const encInfo = secretInfo.encrypted[keyId];\n\n            // We don't actually need the decryption object if it's a passthrough\n            // since we just want to return the key itself. It must be base64\n            // encoded, since this is how a key would normally be stored.\n            if (encInfo.passthrough) return encodeBase64(decryption.get_private_key());\n\n            return decryption.decrypt(encInfo);\n        } finally {\n            if (decryption && decryption.free) decryption.free();\n        }\n    }\n\n    /**\n     * Check if a secret is stored on the server.\n     *\n     * @param {string} name the name of the secret\n     *\n     * @return {object?} map of key name to key info the secret is encrypted\n     *     with, or null if it is not present or not encrypted with a trusted\n     *     key\n     */\n    public async isStored(name: string): Promise<Record<string, ISecretStorageKeyInfo> | null> {\n        // check if secret exists\n        const secretInfo = await this.accountDataAdapter.getAccountDataFromServer<ISecretInfo>(name);\n        if (!secretInfo?.encrypted) return null;\n\n        const ret = {};\n\n        // filter secret encryption keys with supported algorithm\n        for (const keyId of Object.keys(secretInfo.encrypted)) {\n            // get key information from key storage\n            const keyInfo = await this.accountDataAdapter.getAccountDataFromServer<ISecretStorageKeyInfo>(\n                \"m.secret_storage.key.\" + keyId,\n            );\n            if (!keyInfo) continue;\n            const encInfo = secretInfo.encrypted[keyId];\n\n            // only use keys we understand the encryption algorithm of\n            if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {\n                    ret[keyId] = keyInfo;\n                }\n            }\n        }\n        return Object.keys(ret).length ? ret : null;\n    }\n\n    /**\n     * Request a secret from another device\n     *\n     * @param {string} name the name of the secret to request\n     * @param {string[]} devices the devices to request the secret from\n     */\n    public request(this: SecretStorage<MatrixClient>, name: string, devices: string[]): ISecretRequest {\n        const requestId = this.baseApis.makeTxnId();\n\n        const deferred = defer<string>();\n        this.requests.set(requestId, { name, devices, deferred });\n\n        const cancel = (reason: string): void => {\n            // send cancellation event\n            const cancelData = {\n                action: \"request_cancellation\",\n                requesting_device_id: this.baseApis.deviceId,\n                request_id: requestId,\n            };\n            const toDevice = {};\n            for (const device of devices) {\n                toDevice[device] = cancelData;\n            }\n            this.baseApis.sendToDevice(\"m.secret.request\", {\n                [this.baseApis.getUserId()!]: toDevice,\n            });\n\n            // and reject the promise so that anyone waiting on it will be\n            // notified\n            deferred.reject(new Error(reason || \"Cancelled\"));\n        };\n\n        // send request to devices\n        const requestData = {\n            name,\n            action: \"request\",\n            requesting_device_id: this.baseApis.deviceId,\n            request_id: requestId,\n        };\n        const toDevice = {};\n        for (const device of devices) {\n            toDevice[device] = requestData;\n        }\n        logger.info(`Request secret ${name} from ${devices}, id ${requestId}`);\n        this.baseApis.sendToDevice(\"m.secret.request\", {\n            [this.baseApis.getUserId()!]: toDevice,\n        });\n\n        return {\n            requestId,\n            promise: deferred.promise,\n            cancel,\n        };\n    }\n\n    public async onRequestReceived(this: SecretStorage<MatrixClient>, event: MatrixEvent): Promise<void> {\n        const sender = event.getSender();\n        const content = event.getContent();\n        if (sender !== this.baseApis.getUserId()\n            || !(content.name && content.action\n                 && content.requesting_device_id && content.request_id)\n        ) {\n            // ignore requests from anyone else, for now\n            return;\n        }\n        const deviceId = content.requesting_device_id;\n        // check if it's a cancel\n        if (content.action === \"request_cancellation\") {\n            /*\n            Looks like we intended to emit events when we got cancelations, but\n            we never put anything in the _incomingRequests object, and the request\n            itself doesn't use events anyway so if we were to wire up cancellations,\n            they probably ought to use the same callback interface. I'm leaving them\n            disabled for now while converting this file to typescript.\n            if (this._incomingRequests[deviceId]\n                && this._incomingRequests[deviceId][content.request_id]) {\n                logger.info(\n                    \"received request cancellation for secret (\" + sender +\n                    \", \" + deviceId + \", \" + content.request_id + \")\",\n                );\n                this.baseApis.emit(\"crypto.secrets.requestCancelled\", {\n                    user_id: sender,\n                    device_id: deviceId,\n                    request_id: content.request_id,\n                });\n            }\n            */\n        } else if (content.action === \"request\") {\n            if (deviceId === this.baseApis.deviceId) {\n                // no point in trying to send ourself the secret\n                return;\n            }\n\n            // check if we have the secret\n            logger.info(\n                \"received request for secret (\" + sender +\n                \", \" + deviceId + \", \" + content.request_id + \")\",\n            );\n            if (!this.cryptoCallbacks.onSecretRequested) {\n                return;\n            }\n            const secret = await this.cryptoCallbacks.onSecretRequested(\n                sender,\n                deviceId,\n                content.request_id,\n                content.name,\n                this.baseApis.checkDeviceTrust(sender, deviceId),\n            );\n            if (secret) {\n                logger.info(`Preparing ${content.name} secret for ${deviceId}`);\n                const payload = {\n                    type: \"m.secret.send\",\n                    content: {\n                        request_id: content.request_id,\n                        secret: secret,\n                    },\n                };\n                const encryptedContent = {\n                    algorithm: olmlib.OLM_ALGORITHM,\n                    sender_key: this.baseApis.crypto!.olmDevice.deviceCurve25519Key,\n                    ciphertext: {},\n                };\n                await olmlib.ensureOlmSessionsForDevices(\n                    this.baseApis.crypto!.olmDevice,\n                    this.baseApis,\n                    {\n                        [sender]: [\n                            this.baseApis.getStoredDevice(sender, deviceId)!,\n                        ],\n                    },\n                );\n                await olmlib.encryptMessageForDevice(\n                    encryptedContent.ciphertext,\n                    this.baseApis.getUserId()!,\n                    this.baseApis.deviceId!,\n                    this.baseApis.crypto!.olmDevice,\n                    sender,\n                    this.baseApis.getStoredDevice(sender, deviceId)!,\n                    payload,\n                );\n                const contentMap = {\n                    [sender]: {\n                        [deviceId]: encryptedContent,\n                    },\n                };\n\n                logger.info(`Sending ${content.name} secret for ${deviceId}`);\n                this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n            } else {\n                logger.info(`Request denied for ${content.name} secret for ${deviceId}`);\n            }\n        }\n    }\n\n    public onSecretReceived(this: SecretStorage<MatrixClient>, event: MatrixEvent): void {\n        if (event.getSender() !== this.baseApis.getUserId()) {\n            // we shouldn't be receiving secrets from anyone else, so ignore\n            // because someone could be trying to send us bogus data\n            return;\n        }\n\n        if (!olmlib.isOlmEncrypted(event)) {\n            logger.error(\"secret event not properly encrypted\");\n            return;\n        }\n\n        const content = event.getContent();\n\n        const senderKeyUser = this.baseApis.crypto!.deviceList.getUserByIdentityKey(\n            olmlib.OLM_ALGORITHM,\n            event.getSenderKey() || \"\",\n        );\n        if (senderKeyUser !== event.getSender()) {\n            logger.error(\"sending device does not belong to the user it claims to be from\");\n            return;\n        }\n\n        logger.log(\"got secret share for request\", content.request_id);\n        const requestControl = this.requests.get(content.request_id);\n        if (requestControl) {\n            // make sure that the device that sent it is one of the devices that\n            // we requested from\n            const deviceInfo = this.baseApis.crypto!.deviceList.getDeviceByIdentityKey(\n                olmlib.OLM_ALGORITHM,\n                event.getSenderKey()!,\n            );\n            if (!deviceInfo) {\n                logger.log(\n                    \"secret share from unknown device with key\", event.getSenderKey(),\n                );\n                return;\n            }\n            if (!requestControl.devices.includes(deviceInfo.deviceId)) {\n                logger.log(\"unsolicited secret share from device\", deviceInfo.deviceId);\n                return;\n            }\n            // unsure that the sender is trusted.  In theory, this check is\n            // unnecessary since we only accept secret shares from devices that\n            // we requested from, but it doesn't hurt.\n            const deviceTrust = this.baseApis.crypto!.checkDeviceInfoTrust(event.getSender()!, deviceInfo);\n            if (!deviceTrust.isVerified()) {\n                logger.log(\"secret share from unverified device\");\n                return;\n            }\n\n            logger.log(\n                `Successfully received secret ${requestControl.name} ` +\n                `from ${deviceInfo.deviceId}`,\n            );\n            requestControl.deferred.resolve(content.secret);\n        }\n    }\n\n    private async getSecretStorageKey(\n        keys: Record<string, ISecretStorageKeyInfo>,\n        name: string,\n    ): Promise<[string, IDecryptors]> {\n        if (!this.cryptoCallbacks.getSecretStorageKey) {\n            throw new Error(\"No getSecretStorageKey callback supplied\");\n        }\n\n        const returned = await this.cryptoCallbacks.getSecretStorageKey({ keys }, name);\n\n        if (!returned) {\n            throw new Error(\"getSecretStorageKey callback returned falsey\");\n        }\n        if (returned.length < 2) {\n            throw new Error(\"getSecretStorageKey callback returned invalid data\");\n        }\n\n        const [keyId, privateKey] = returned;\n        if (!keys[keyId]) {\n            throw new Error(\"App returned unknown key from getSecretStorageKey!\");\n        }\n\n        if (keys[keyId].algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n            const decryption = {\n                encrypt: function(secret: string): Promise<IEncryptedPayload> {\n                    return encryptAES(secret, privateKey, name);\n                },\n                decrypt: function(encInfo: IEncryptedPayload): Promise<string> {\n                    return decryptAES(encInfo, privateKey, name);\n                },\n            };\n            return [keyId, decryption];\n        } else {\n            throw new Error(\"Unknown key type: \" + keys[keyId].algorithm);\n        }\n    }\n}\n"],"mappings":"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"}